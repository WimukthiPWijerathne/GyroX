#include <Wire.h>
#include <MPU6050_light.h>
#include <WiFi.h>
#include <WebServer.h>

// WiFi Credentials
const char* ssid = "randilsk";
const char* password = "lkci2721";
WebServer server(80);

// Motor Pin Definitions
const int AIN1 = 25;
const int AIN2 = 33;
const int PWMA = 32;
const int BIN1 = 27;
const int BIN2 = 14;
const int PWMB = 13;
const int STBY = 26;

const int PWM_FREQ = 1000;
const int PWM_RESOLUTION = 8;
const int PWM_CHANNEL_A = 0;
const int PWM_CHANNEL_B = 1;
const int PWM_MAX = 255;
const int MIN_PWM_THRESHOLD = 55;
const float LOOP_INTERVAL_US = 5000; // 5ms = 200Hz control loop (in microseconds)
const float DEAD_BAND = 0.1; // Deadband to prevent motor jitter

// PID Constants (Base values)
const float KP_BASE = 1.5; // Reduced for stability
const float KI_BASE = 0.3; // Reduced to minimize windup
const float KD_BASE = 0.8; // Reduced for smoother damping
const float NON_LINEAR_GAIN = 2.5; // Adjusted for dynamic response
const float ANGLE_THRESHOLD = 4.0; // Threshold for non-linear control
const float MAX_INTEGRAL = 30.0; // Tighter integral limit
float TARGET_ANGLE = 0.019; // Default target angle for balance
const float MAX_PWM_NORMAL = 115.0;
const float MAX_PWM_BOOST = 235.0; // Higher PWM for large angles
const float MAX_TILT_ANGLE = 25.0; // Safety limit to stop motors

// Movement Angles
const float FORWARD_ANGLE_OFFSET = -1.5; // Reduced for smoother movement
const float BACKWARD_ANGLE_OFFSET = 1.5; // Reduced for smoother movement

// Complementary Filter
const float COMPLEMENTARY_ALPHA = 0.99; // Weight for gyro (high trust in gyro)
const float ALPHA_DYNAMIC_THRESHOLD = 5.0; // Angular rate (deg/s) for dynamic filter adjustment

// Dynamic Compensation
const float KP_SMALL_ERROR = 1.0; // Lower KP for small errors (< 1 degree)
const float ERROR_THRESHOLD = 1.0; // Threshold for small error gains
const float VELOCITY_DAMPING = 0.2; // Velocity feedback gain
const float TRANSITION_RATE = 0.01; // Rate for smooth target angle transitions (deg/loop)

// Global Variables
MPU6050 mpu(Wire);
float previousError = 0.0;
float integralSum = 0.0;
float filteredAngle = 0.0;
float lastTargetAngle = 0.019; // For smooth transitions
float estimatedVelocity = 0.0; // Estimated from PWM output
String currentCommand = ""; // Start with no command (do nothing)
bool isBalancing = false;

void handleCommand() {
  String command;
  if (server.hasArg("command")) {
    command = server.arg("command");
  } else if (server.hasArg("plain")) {
    command = server.arg("plain");
  } else {
    server.send(400, "text/plain", "Body not found");
    return;
  }
  command.trim();
  Serial.println("Command received: " + command);

  if (command == "forward" || command == "backward" || command == "stop") {
    currentCommand = command;
    isBalancing = true;
    server.send(200, "text/plain", "Command accepted");
  } else if (command == "left") {
    currentCommand = command;
    isBalancing = false;
    integralSum = 0.0; // Reset integral
    server.send(200, "text/plain", "Command accepted");
  } else {
    server.send(200, "text/plain", "Command ignored");
  }
}

void driveMotor(float pidValue) {
  // Safety check for excessive tilt
  if (abs(filteredAngle) > MAX_TILT_ANGLE) {
    digitalWrite(AIN1, LOW);
    digitalWrite(AIN2, LOW);
    digitalWrite(BIN1, LOW);
    digitalWrite(BIN2, LOW);
    ledcWrite(PWM_CHANNEL_A, 0);
    ledcWrite(PWM_CHANNEL_B, 0);
    return;
  }

  // Apply deadband
  if (abs(pidValue) < DEAD_BAND) {
    pidValue = 0;
  }

  // Dynamic PWM limit
  float maxPWM = (abs(filteredAngle - TARGET_ANGLE) > ANGLE_THRESHOLD) ? MAX_PWM_BOOST : MAX_PWM_NORMAL;
  float limitedValue = constrain(pidValue, -maxPWM, maxPWM);
  int pwm = (int)abs(limitedValue);

  // Update estimated velocity (approximated from PWM)
  estimatedVelocity = 0.9 * estimatedVelocity + 0.1 * limitedValue; // Low-pass filter

  // Apply minimum PWM threshold
  if (pwm > 0 && pwm < MIN_PWM_THRESHOLD) {
    pwm = MIN_PWM_THRESHOLD;
  }

  // Motor direction control
  if (limitedValue > 0) { // Forward
    digitalWrite(AIN1, HIGH);
    digitalWrite(AIN2, LOW);
    digitalWrite(BIN1, LOW);
    digitalWrite(BIN2, HIGH);
  } else if (limitedValue < 0) { // Backward
    digitalWrite(AIN1, LOW);
    digitalWrite(AIN2, HIGH);
    digitalWrite(BIN1, HIGH);
    digitalWrite(BIN2, LOW);
  } else { // Stop
    digitalWrite(AIN1, LOW);
    digitalWrite(AIN2, LOW);
    digitalWrite(BIN1, LOW);
    digitalWrite(BIN2, LOW);
    pwm = 0;
  }

  ledcWrite(PWM_CHANNEL_A, pwm);
  ledcWrite(PWM_CHANNEL_B, pwm);
}

float computePID(float currentAngle, float dt, float angularRate) {
  float error = TARGET_ANGLE - currentAngle;

  // Dynamic PID gains based on error size
  float kp = (abs(error) < ERROR_THRESHOLD) ? KP_SMALL_ERROR : KP_BASE;
  float ki = KI_BASE;
  float kd = KD_BASE;

  // Proportional term with non-linear gain
  float pTerm = kp * error;
  if (abs(error) > ANGLE_THRESHOLD) {
    pTerm *= (1.0 + NON_LINEAR_GAIN * (abs(error) - ANGLE_THRESHOLD) / ANGLE_THRESHOLD);
  }

  // Integral with anti-windup (disabled when tilt is excessive)
  if (abs(filteredAngle) < MAX_TILT_ANGLE) {
    integralSum = constrain(integralSum + error * dt, -MAX_INTEGRAL, MAX_INTEGRAL);
  }
  float iTerm = ki * integralSum;

  // Derivative term
  float derivative = (error - previousError) / dt;
  previousError = error;

  // Velocity damping
  float velocityTerm = -VELOCITY_DAMPING * estimatedVelocity;

  // Compute PID output
  float pidOutput = pTerm + iTerm + kd * derivative + velocityTerm;
  return pidOutput;
}

void setup() {
  Serial.begin(115200);
  Wire.begin(4, 15); // SDA, SCL

  // Motor setup
  pinMode(AIN1, OUTPUT);
  pinMode(AIN2, OUTPUT);
  pinMode(BIN1, OUTPUT);
  pinMode(BIN2, OUTPUT);
  pinMode(PWMA, OUTPUT);
  pinMode(PWMB, OUTPUT);
  pinMode(STBY, OUTPUT);
  digitalWrite(STBY, HIGH);

  ledcSetup(PWM_CHANNEL_A, PWM_FREQ, PWM_RESOLUTION);
  ledcAttachPin(PWMA, PWM_CHANNEL_A);
  ledcSetup(PWM_CHANNEL_B, PWM_FREQ, PWM_RESOLUTION);
  ledcAttachPin(PWMB, PWM_CHANNEL_B);

  // MPU6050 setup
  if (mpu.begin() != 0) {
    Serial.println(F("MPU6050 connection failed. Check wiring or address."));
    while (1);
  }

  Serial.println(F("Calibrating... Keep MPU still"));
  delay(2000); // Increased calibration time
  mpu.calcOffsets(true, true); // Calibrate both gyro and accel
  Serial.println(F("Calibration complete!"));

  // WiFi setup
  WiFi.begin(ssid, password);
  Serial.print("Connecting to WiFi...");
  while (WiFi.status() != WL_CONNECTED) {
    delay(500);
    Serial.print(".");
  }
  Serial.println("\nConnected to WiFi");
  Serial.println(WiFi.localIP());

  server.on("/command", HTTP_POST, handleCommand);
  server.on("/ping", HTTP_GET, []() {
    server.send(200, "text/plain", "pong");
  });

  server.begin();
  Serial.println("HTTP server started");

  // Initialize motors off
  digitalWrite(AIN1, LOW);
  digitalWrite(AIN2, LOW);
  digitalWrite(BIN1, LOW);
  digitalWrite(BIN2, LOW);
  ledcWrite(PWM_CHANNEL_A, 0);
  ledcWrite(PWM_CHANNEL_B, 0);

  mpu.update();
  filteredAngle = mpu.getAngleX();
}

void loop() {
  static unsigned long lastControlTime = 0;
  static unsigned long lastDebugTime = 0;
  unsigned long now = micros();

  // Handle WiFi clients (limit frequency to reduce interference)
  static unsigned long lastClientTime = 0;
  if (now - lastClientTime >= 10000) { // Every 10ms
    server.handleClient();
    lastClientTime = now;
  }

  // Only run balancing logic if isBalancing is true
  if (isBalancing) {
    // Smoothly transition target angle
    float desiredTargetAngle;
    if (currentCommand == "forward") {
      desiredTargetAngle = 0.019 + FORWARD_ANGLE_OFFSET;
    } else if (currentCommand == "backward") {
      desiredTargetAngle = 0.019 + BACKWARD_ANGLE_OFFSET;
    } else {
      desiredTargetAngle = 0.019; // Default for "stop"
    }
    // Linear interpolation for smooth transition
    TARGET_ANGLE = lastTargetAngle + constrain(desiredTargetAngle - lastTargetAngle, -TRANSITION_RATE, TRANSITION_RATE);
    lastTargetAngle = TARGET_ANGLE;

    // Control loop at 200Hz
    if (now - lastControlTime >= LOOP_INTERVAL_US) {
      float dt = (now - lastControlTime) / 1000000.0; // Micros to seconds
      lastControlTime = now;

      mpu.update();
      float accelAngle = mpu.getAccAngleX(); // Accelerometer-based angle
      float gyroRate = mpu.getGyroX(); // Angular velocity (deg/s)
      // Dynamic complementary filter
      float alpha = (abs(gyroRate) > ALPHA_DYNAMIC_THRESHOLD) ? 0.995 : COMPLEMENTARY_ALPHA;
      filteredAngle = alpha * (filteredAngle + gyroRate * dt) + (1 - alpha) * accelAngle;

      float pidOutput = computePID(filteredAngle, dt, gyroRate);
      driveMotor(pidOutput);
    }

    // Debug output every 200ms
    if (now - lastDebugTime >= 200000) {
      Serial.printf("Angle: %.2f | Error: %.2f | PID: %.2f | Command: %s | Integral: %.2f | Velocity: %.2f\n",
                    filteredAngle, TARGET_ANGLE - filteredAngle,
                    computePID(filteredAngle, LOOP_INTERVAL_US / 1000000.0, mpu.getGyroX()),
                    currentCommand.c_str(), integralSum, estimatedVelocity);
      lastDebugTime = now;
    }
  } else {
    // Keep motors off when not balancing
    digitalWrite(AIN1, LOW);
    digitalWrite(AIN2, LOW);
    digitalWrite(BIN1, LOW);
    digitalWrite(BIN2, LOW);
    ledcWrite(PWM_CHANNEL_A, 0);
    ledcWrite(PWM_CHANNEL_B, 0);
    integralSum = 0.0; // Reset integral
    estimatedVelocity = 0.0; // Reset velocity estimate
  }
}